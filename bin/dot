#!/bin/bash

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

debug() {
    if [ "${DEBUG:-false}" = "true" ]; then
        # Use gdate if available (GNU coreutils on macOS), otherwise use standard date without milliseconds
        if command -v gdate &> /dev/null; then
            timestamp=$(gdate '+%H:%M:%S.%3N')
        else
            timestamp=$(date '+%H:%M:%S')
        fi
        echo "[$timestamp] $1"
    fi
}

update_dotfiles_repo() {
    debug "Updating dotfiles repository..."
    cd "$DOTFILES_DIR"

    # Check if we're on main branch - if not, skip git update
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    debug "Current branch: $current_branch"
    if [ "$current_branch" != "main" ]; then
        debug "Not on main branch, skipping git update"
        return 0
    fi

    # Check if there are changes to pull first (avoid slow fetch if unnecessary)
    LOCAL=$(git rev-parse @ 2>/dev/null)
    REMOTE=$(git rev-parse @{u} 2>/dev/null)
    debug "Local commit: $LOCAL"
    debug "Remote commit (before fetch): $REMOTE"

    # Only fetch if we might be behind
    debug "Fetching from origin main..."
    if ! git fetch origin main 2>/dev/null; then
        echo "Error: Failed to fetch from remote"
        exit 1
    fi
    debug "Fetch completed successfully"

    # Re-check after fetch
    REMOTE=$(git rev-parse @{u} 2>/dev/null)
    debug "Remote commit (after fetch): $REMOTE"

    if [ "$LOCAL" != "$REMOTE" ]; then
        echo "Pulling latest changes from remote..."
        debug "Local and remote differ, pulling changes..."
        if ! git pull --ff-only 2>/dev/null; then
            echo "Error: Failed to pull changes. Please resolve any conflicts manually."
            exit 1
        fi
        echo "Successfully updated dotfiles repository"
        debug "Repository updated successfully"
    else
        debug "Repository is up to date"
    fi
}

start_background_fetch() {
    cd "$DOTFILES_DIR"

    # Start fetch in background (always fetch to keep origin/main updated)
    debug "Starting background fetch from origin main..."
    git fetch origin main >/dev/null 2>&1 &
    FETCH_PID=$!
    debug "Background fetch started with PID: $FETCH_PID"
}

check_for_updates() {
    cd "$DOTFILES_DIR"

    # If no fetch was started, nothing to check
    if [ -z "$FETCH_PID" ]; then
        debug "No background fetch to check"
        return 0
    fi

    # Wait for fetch to complete if it's still running
    if kill -0 $FETCH_PID 2>/dev/null; then
        debug "Waiting for background fetch to complete..."
        wait $FETCH_PID
        debug "Background fetch completed"
    else
        debug "Background fetch already completed"
    fi

    # Check if main branch has updates available (compare main with origin/main)
    LOCAL_MAIN=$(git rev-parse main 2>/dev/null)
    REMOTE_MAIN=$(git rev-parse origin/main 2>/dev/null)
    debug "After fetch - main: $LOCAL_MAIN, origin/main: $REMOTE_MAIN"

    if [ "$LOCAL_MAIN" != "$REMOTE_MAIN" ]; then
        echo ""
        echo "ðŸ“¦ Updates available! Run 'dot update' to pull the latest changes."
    fi
}

cmd_run() {
    start_background_fetch
    "$SCRIPT_DIR/bootstrap"

    cd "$DOTFILES_DIR"
    ruby -r ./lib/dotfiles.rb -e 'Dotfiles::Runner.new.run'

    check_for_updates
    debug "Run complete"
}

cmd_update() {
    local git_flags=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-gpg-sign)
                git_flags="$git_flags --no-gpg-sign"
                shift
                ;;
            --no-verify)
                git_flags="$git_flags --no-verify"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    update_dotfiles_repo

    cd "$DOTFILES_DIR"
    GIT_COMMIT_FLAGS="$git_flags" ruby -r ./lib/dotfiles.rb -e 'Dotfiles::Updater.new.run'
}

cmd_help() {
    cat <<EOF
dot - Dotfiles management tool

Usage: dot <command> [options]

Commands:
  run       Set up development environment from scratch
  update    Update dotfiles from the system
  help      Show this help message

Options (for update command):
  --no-gpg-sign    Skip GPG signing when committing
  --no-verify      Skip git pre-commit and commit-msg hooks

Examples:
  dot run                              # Initial setup
  dot update                           # Update dotfiles
  dot update --no-gpg-sign             # Update without GPG signing
  dot update --no-gpg-sign --no-verify # Update without GPG or hooks
  DEBUG=true dot run                   # Run with debug output
EOF
}

main() {
    if [ $# -eq 0 ]; then
        cmd_help
        exit 1
    fi

    case "$1" in
        run)
            cmd_run
            ;;
        update)
            shift
            cmd_update "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo "Error: Unknown command '$1'"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
